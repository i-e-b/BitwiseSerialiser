using System;
using System.Linq;
using JetBrains.Annotations;

namespace BitwiseSerialiser;
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedAutoPropertyAccessor.Global
// ReSharper disable UnusedType.Global
// ReSharper disable AutoPropertyCanBeMadeGetOnly.Global
// ReSharper disable BuiltInTypeReferenceStyle
// ReSharper disable MemberCanBePrivate.Global

/// <summary>
/// Marks a class as representing the fields in a byte array.
/// Each FIELD in the marked class will need to have a byte order and position marker,
/// either <see cref="BigEndianAttribute"/> or <see cref="ByteLayoutChildAttribute"/>
/// </summary>
[MeansImplicitUse, AttributeUsage(AttributeTargets.Class)]
public class ByteLayoutAttribute : Attribute
{
    /// <summary>
    /// Method definition for <see cref="ByteLayoutAttribute.SpecialiseWith"/>
    /// </summary>
    public delegate Type? SpecialisedType();
    
    /// <summary>
    /// [Optional] Name of a function method on this type, that can give
    /// a specialised version of this class.
    /// <p/>
    /// The named method should be a public instance method
    /// that matches<see cref="SpecialisedType"/>
    /// <p/>
    /// The specialise method will be run after the base type has
    /// been populated, and if it returns <c>null</c>, the base type
    /// will be used.
    /// </summary>
    public string? SpecialiseWith { get; set; }
}

/// <summary>
/// Marks a field as representing a subset of fields in a byte array.
/// The child value should be marked with <see cref="ByteLayoutAttribute"/>
/// </summary>
[MeansImplicitUse, AttributeUsage(AttributeTargets.Field)]
public class ByteLayoutChildAttribute : Attribute
{
    /// <summary>
    /// Position in bitstream relative to other fields in the container.
    /// This should start at zero and increment by 1 for each field.
    /// This is NOT the bit or byte offset.
    /// </summary>
    public int Order { get; set; }

    /// <summary>
    /// Represents a subset of byte field data.
    /// </summary>
    /// <param name="order">The order through the byte array in which this subset should be processed</param>
    public ByteLayoutChildAttribute(int order)
    {
        Order = order;
    }
}


/// <summary>
/// Marks a field as representing a subset of fields in a byte array.
/// The child is repeated in the parent a fixed number of times.
/// The child value should be marked with <see cref="ByteLayoutAttribute"/>
/// For a variable number of repeats, see <see cref="ByteLayoutVariableChildAttribute"/>
/// </summary>
[MeansImplicitUse, AttributeUsage(AttributeTargets.Field)]
public class ByteLayoutMultiChildAttribute : Attribute
{
    /// <summary>
    /// Number of times this child is repeated in the parent.
    /// This is fixed. For a variable number, see <see cref="ByteLayoutVariableChildAttribute"/>
    /// </summary>
    public int Count { get; set; }
    
    /// <summary>
    /// Position in bitstream relative to other fields in the container.
    /// This should start at zero and increment by 1 for each field.
    /// This is NOT the bit or byte offset.
    /// </summary>
    public int Order { get; set; }

    /// <summary>
    /// Represents a subset of byte field data, with the child pattern
    /// repeated a fixed number of times.
    /// </summary>
    /// <param name="count">Number of times the child is repeated</param>
    /// <param name="order">The order through the byte array in which this subset should be processed</param>
    public ByteLayoutMultiChildAttribute(int count, int order)
    {
        Count = count;
        Order = order;
    }
}

/// <summary>
/// Marks a field as representing a subset of fields in a byte array.
/// The child value should be marked with <see cref="ByteLayoutAttribute"/>
/// For a fixed number of repeats, see <see cref="ByteLayoutMultiChildAttribute"/>.
/// <p></p>
/// The child is repeated in the parent a variable number of times, where
/// that number is generated by a named function of the type.
/// <p></p>
/// The function should be a public instance method that takes
/// no parameters and returns an int.
/// The function is allowed to return zero or negative values,
/// which will be interpreted as empty. The resulting byte array
/// will be non-null and zero length.
/// <p></p>
/// When based on another field, that field MUST be in earlier order than
/// the variable byte string.
/// </summary>
[MeansImplicitUse, AttributeUsage(AttributeTargets.Field)]
public class ByteLayoutVariableChildAttribute : Attribute
{
    /// <summary>
    /// Name of a method on this container class
    /// that will give the number of times the child is
    /// repeated. For a fixed number of repeats, see <see cref="ByteLayoutMultiChildAttribute"/>.
    /// </summary>
    public string Source { get; set; }

    /// <summary>
    /// Position in bitstream relative to other fields in the container.
    /// This should start at zero and increment by 1 for each field.
    /// This is NOT the bit or byte offset.
    /// </summary>
    public int Order { get; set; }

    /// <summary>
    /// Represents a subset of byte field data.
    /// </summary>
    /// <param name="source">Name of a method on this container class
    /// that will give the number of times the child is repeated</param>
    /// <param name="order">The order through the byte array in which this subset should be processed</param>
    public ByteLayoutVariableChildAttribute(string source, int order)
    {
        Source = source;
        Order = order;
    }
}

/// <summary>
/// Indicates that a byte value field should always have a fixed value.
/// <p></p>
/// On serialisation, this fixed value will be written to the output.
/// <p></p>
/// On deserialisation, the actual <b>supplied</b> value will be populated
/// into the target object field.
/// </summary>
[MeansImplicitUse, AttributeUsage(AttributeTargets.Field)]
public class FixedValueAttribute : Attribute
{
    /// <summary>
    /// Expected value
    /// </summary>
    public byte[] Value { get; set; }

    /// <summary>
    /// Indicates that a byte value field should always have a fixed value
    /// </summary>
    public FixedValueAttribute(params byte[] value)
    {
        Value = value;
    }
}

/// <summary>
/// Represents an unsigned integer value, taking the
/// given number of bytes (1..8), MSB first.
/// Can handle non standard byte counts (e.g. 3 bytes into a UInt32)
/// </summary>
[MeansImplicitUse, AttributeUsage(AttributeTargets.Field)]
public class BigEndianAttribute : Attribute
{
    /// <summary>
    /// Byte size of the field.
    /// Number of bytes that are used for this field.
    /// </summary>
    public int Bytes { get; set; }
    
    /// <summary>
    /// Position in bitstream relative to other fields in the container.
    /// This should start at zero and increment by 1 for each field.
    /// This is NOT the bit or byte offset.
    /// </summary>
    public int Order { get; set; }

    /// <summary>
    /// Represents an unsigned integer value, taking the
    /// given number of bytes (1..8), MSB first.
    /// Can handle non standard byte counts (e.g. 3 bytes into a UInt32)
    /// </summary>
    /// <param name="bytes">Number of bytes in this value. Can be any number from 1 to 8 inclusive.</param>
    /// <param name="order">The order through the byte array in which this value should be processed</param>
    public BigEndianAttribute(int bytes, int order)
    {
        Bytes = bytes;
        Order = order;
    }

    /// <summary>
    /// List of field types that BigEndian can be validly applied to
    /// </summary>
    public static readonly Type[] AcceptableTypes =
    {
        typeof(byte), typeof(UInt16), typeof(UInt32), typeof(UInt64),
        typeof(Int16), typeof(Int32), typeof(Int64)
    };

    /// <summary>
    /// Returns true if the given type can be used for BigEndian fields
    /// </summary>
    public static bool IsAcceptable(Type? fieldType)
    {
        return AcceptableTypes.Contains(fieldType);
    }
}

/// <summary>
/// Represents an unsigned integer value, taking the
/// given number of BITS (1..64), MSB first.
/// Can handle non standard bit counts (e.g. 13 bits into a UInt16)
/// <para></para>
/// A sequence of BigEndianPartial attributes should line up to a byte boundary.
/// </summary>
[MeansImplicitUse, AttributeUsage(AttributeTargets.Field)]
public class BigEndianPartialAttribute : Attribute
{
    /// <summary>
    /// BIT size of the field.
    /// Number of bit that are used for this field.
    /// </summary>
    public int Bits { get; set; }
    
    /// <summary>
    /// Position in bitstream relative to other fields in the container.
    /// This should start at zero and increment by 1 for each field.
    /// This is NOT the bit or byte offset.
    /// </summary>
    public int Order { get; set; }

    /// <summary>
    /// Represents an unsigned integer value, taking the
    /// given number of bits (1..64), MSB first.
    /// Can handle non standard bit counts (e.g. 13 bits into a UInt16)
    /// </summary>
    /// <param name="bits">Number of bits in this value. Can be any number from 1 to 64 inclusive.</param>
    /// <param name="order">The order through the byte array in which this value should be processed</param>
    public BigEndianPartialAttribute(int bits, int order)
    {
        Bits = bits;
        Order = order;
    }

    /// <summary>
    /// List of field types that BigEndianPartial can be validly applied to
    /// </summary>
    public static readonly Type[] AcceptableTypes =
    {
        typeof(byte), typeof(UInt16), typeof(UInt32), typeof(UInt64),
        typeof(Int16), typeof(Int32), typeof(Int64)
    };

    /// <summary>
    /// Returns true if the given type can be used for BigEndian fields
    /// </summary>
    public static bool IsAcceptable(Type? fieldType)
    {
        return AcceptableTypes.Contains(fieldType);
    }
}

/// <summary>
/// Represents an unsigned integer value, taking the
/// given number of bytes (1..8), LSB first.
/// Can handle non standard byte counts (e.g. 3 bytes into a UInt32)
/// </summary>
[MeansImplicitUse, AttributeUsage(AttributeTargets.Field)]
public class LittleEndianAttribute : Attribute
{
    /// <summary>
    /// Byte size of the field.
    /// Number of bytes that are used for this field.
    /// </summary>
    public int Bytes { get; set; }
    
    /// <summary>
    /// Position in bitstream relative to other fields in the container.
    /// This should start at zero and increment by 1 for each field.
    /// This is NOT the bit or byte offset.
    /// </summary>
    public int Order { get; set; }

    /// <summary>
    /// Represents an unsigned integer value, taking the
    /// given number of bytes (1..8), LSB first.
    /// Can handle non standard byte counts (e.g. 3 bytes into a UInt32)
    /// </summary>
    /// <param name="bytes">Number of bytes in this value. Can be any number from 1 to 8 inclusive.</param>
    /// <param name="order">The order through the byte array in which this value should be processed</param>
    public LittleEndianAttribute(int bytes, int order)
    {
        Bytes = bytes;
        Order = order;
    }

    /// <summary>
    /// List of field types that BigEndian can be validly applied to
    /// </summary>
    public static readonly Type[] AcceptableTypes =
    {
        typeof(byte), typeof(UInt16), typeof(UInt32), typeof(UInt64),
        typeof(Int16), typeof(Int32), typeof(Int64)
    };

    /// <summary>
    /// Returns true if the given type can be used for BigEndian fields
    /// </summary>
    public static bool IsAcceptable(Type? fieldType)
    {
        return AcceptableTypes.Contains(fieldType);
    }
}

/// <summary>
/// Represents a known-length list of bytes in input order
/// </summary>
[MeansImplicitUse, AttributeUsage(AttributeTargets.Field)]
public class ByteStringAttribute : Attribute
{
    /// <summary>
    /// Byte size of the field.
    /// Number of bytes that are used for this field.
    /// </summary>
    public int Bytes { get; set; }
    
    /// <summary>
    /// Position in bitstream relative to other fields in the container.
    /// This should start at zero and increment by 1 for each field.
    /// This is NOT the bit or byte offset.
    /// </summary>
    public int Order { get; set; }

    /// <summary>
    /// Represents a known-length list of bytes in input order
    /// </summary>
    /// <param name="bytes">Number of bytes in this value</param>
    /// <param name="order">The order through the byte array in which this value should be processed</param>
    public ByteStringAttribute(int bytes, int order)
    {
        Bytes = bytes;
        Order = order;
    }

    /// <summary>
    /// List of field types that BigEndian can be validly applied to
    /// </summary>
    public static readonly Type[] AcceptableTypes = { typeof(byte[]) };

    /// <summary>
    /// Returns true if the given type can be used for BigEndian fields
    /// </summary>
    public static bool IsAcceptable(Type? fieldType)
    {
        return AcceptableTypes.Contains(fieldType);
    }
}

/// <summary>
/// Represents a known-length list of bytes in input order, interpreted as an ASCII string
/// </summary>
[MeansImplicitUse, AttributeUsage(AttributeTargets.Field)]
public class AsciiStringAttribute : Attribute
{
    /// <summary>
    /// Byte size of the field.
    /// Number of bytes that are used for this field.
    /// </summary>
    public int Bytes { get; set; }
    
    /// <summary>
    /// Position in bitstream relative to other fields in the container.
    /// This should start at zero and increment by 1 for each field.
    /// This is NOT the bit or byte offset.
    /// </summary>
    public int Order { get; set; }

    /// <summary>
    /// Represents a known-length list of bytes in input order
    /// </summary>
    /// <param name="bytes">Number of bytes in this value</param>
    /// <param name="order">The order through the byte array in which this value should be processed</param>
    public AsciiStringAttribute(int bytes, int order)
    {
        Bytes = bytes;
        Order = order;
    }

    /// <summary>
    /// List of field types that BigEndian can be validly applied to
    /// </summary>
    public static readonly Type[] AcceptableTypes = { typeof(string) };

    /// <summary>
    /// Returns true if the given type can be used for BigEndian fields
    /// </summary>
    public static bool IsAcceptable(Type? fieldType)
    {
        return AcceptableTypes.Contains(fieldType);
    }
}

/// <summary>
/// Represents an unknown length list of bytes in input order,
/// from the current position to the end of input.
/// <para></para>
/// This should be the last field by order.
/// During serialisation, this is treated as a normal byte string.
/// </summary>
[MeansImplicitUse, AttributeUsage(AttributeTargets.Field)]
public class RemainingBytesAttribute : Attribute
{
    /// <summary>
    /// Position in bitstream relative to other fields in the container.
    /// This should start at zero and increment by 1 for each field.
    /// This is NOT the bit or byte offset.
    /// </summary>
    public int Order { get; set; }

    /// <summary>
    /// Represents a list of bytes in input order, from current position to end of input.
    /// </summary>
    /// <param name="order">The order through the byte array in which this value should be processed. This should be the last field by order</param>
    public RemainingBytesAttribute(int order)
    {
        Order = order;
    }

    /// <summary>
    /// List of field types that BigEndian can be validly applied to
    /// </summary>
    public static readonly Type[] AcceptableTypes = { typeof(byte[]) };

    /// <summary>
    /// Returns true if the given type can be used for BigEndian fields
    /// </summary>
    public static bool IsAcceptable(Type? fieldType)
    {
        return AcceptableTypes.Contains(fieldType);
    }
}

/// <summary>
/// Represents a list of bytes in input order, whose length is
/// generated by a named function of the type.
/// <para></para>
/// The function should be a public instance method that takes
/// no parameters and returns an int.
/// The function is allowed to return zero or negative values,
/// which will be interpreted as empty. The resulting byte array
/// will be non-null and zero length.
/// <para></para>
/// When based on another field, that field MUST be in earlier order than
/// the variable byte string.
/// </summary>
[MeansImplicitUse, AttributeUsage(AttributeTargets.Field)]
public class VariableByteStringAttribute : Attribute
{
    /// <summary>
    /// Name of a method on this container class
    /// that will give the size of this byte string.
    /// </summary>
    public string Source { get; set; }
    
    /// <summary>
    /// Position in bitstream relative to other fields in the container.
    /// This should start at zero and increment by 1 for each field.
    /// This is NOT the bit or byte offset.
    /// </summary>
    public int Order { get; set; }
        
    /// <summary>
    /// Set attribute with source and order
    /// </summary>
    /// <param name="source">Name of a method on this container class
    /// that will give the size of this byte string.</param>
    /// <param name="order">Position in bitstream relative to other fields in the container.
    /// This should start at zero and increment by 1 for each field.
    /// This is NOT the bit or byte offset.</param>
    public VariableByteStringAttribute(string source, int order)
    {
        Source = source;
        Order = order;
    }

    /// <summary>
    /// List of field types that BigEndian can be validly applied to
    /// </summary>
    public static readonly Type[] AcceptableTypes = { typeof(byte[]) };

    /// <summary>
    /// Returns true if the given type can be used for BigEndian fields
    /// </summary>
    public static bool IsAcceptable(Type? fieldType)
    {
        return AcceptableTypes.Contains(fieldType);
    }
}


/// <summary>
/// Represents a variable length list of bytes in input order.
/// The string ends when the given byte is reached.
/// The value <b>includes</b> this byte.
/// <p></p>
/// For example, with a <c>StopValue</c> of <c>0x00</c>, this
/// will read a C-style null-terminated character string.
/// </summary>
[MeansImplicitUse, AttributeUsage(AttributeTargets.Field)]
public class ValueTerminatedByteStringAttribute : Attribute
{
    /// <summary>
    /// Byte size of the field.
    /// Number of bytes that are used for this field.
    /// </summary>
    public byte StopValue { get; set; }
    
    /// <summary>
    /// Position in bitstream relative to other fields in the container.
    /// This should start at zero and increment by 1 for each field.
    /// This is NOT the bit or byte offset.
    /// </summary>
    public int Order { get; set; }

    /// <summary>
    /// Represents a variable length list of bytes in input order
    /// </summary>
    /// <param name="stopValue">Byte value that indicates the end of this string</param>
    /// <param name="order">The order through the byte array in which this value should be processed</param>
    public ValueTerminatedByteStringAttribute(byte stopValue, int order)
    {
        StopValue = stopValue;
        Order = order;
    }

    /// <summary>
    /// List of field types that this can be validly applied to
    /// </summary>
    public static readonly Type[] AcceptableTypes = { typeof(byte[]) };

    /// <summary>
    /// Returns true if the given type can be used for BigEndian fields
    /// </summary>
    public static bool IsAcceptable(Type? fieldType)
    {
        return AcceptableTypes.Contains(fieldType);
    }
}